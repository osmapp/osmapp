import styled from '@emotion/styled';
import {
  DirectionsAutocomplete,
  getOptionCoords,
  getOptionLabel,
} from './DirectionsAutocomplete';
import React, { useEffect, useRef, useState } from 'react';
import { Button, IconButton, Paper, Stack, Typography } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import SearchIcon from '@mui/icons-material/Search';
import { convertHexToRgba } from '../utils/colorUtils';
import { t } from '../../services/intl';
import { ModeToggler } from './ModeToggler';
import Router, { useRouter } from 'next/router';
import { usePersistedState } from '../utils/usePersistedState';
import {
  destroyRouting,
  getLastMode,
  handleRouting,
  splitByFirstTilda,
} from './utils';
import { encodeUrl } from '../../helpers/utils';
import { isImperial } from '../helpers';
import { getLabel } from '../../helpers/featureLabel';
import { getLastFeature } from '../../services/lastFeatureStorage';

const Wrapper = styled(Stack)`
  position: absolute;
  top: 8px;
  left: 8px;
  z-index: 10;
  width: 340px;
`;

const StyledPaper = styled(Paper)`
  backdrop-filter: blur(10px);
  background: ${({ theme }) =>
    convertHexToRgba(theme.palette.background.paper, 0.9)};
  padding: ${({ theme }) => theme.spacing(2)};
`;

const useReactToUrl = (
  setMode: (param: ((current: string) => string) | string) => void,
  setFrom: (value: any) => void,
  setTo: (value: any) => void,
  setResult,
) => {
  const lastModeWasSetRef = useRef(false);

  const router = useRouter();
  const [, mode, from, to] = router.query.all;
  useEffect(() => {
    const [fromCoords, fromLabel] = splitByFirstTilda(from);
    const [toCoords, toLabel] = splitByFirstTilda(to);

    if (mode && fromCoords && toCoords) {
      setMode(mode);
      setFrom({
        star: {
          center: fromCoords.split(',').map(Number),
          label: fromLabel || fromCoords,
        },
      });
      setTo({
        star: {
          center: toCoords.split(',').map(Number),
          label: toLabel || toCoords,
        },
      });
      handleRouting(mode, fromCoords, toCoords).then(setResult);
    } else {
      if (lastModeWasSetRef.current === false && getLastMode()) {
        setMode(getLastMode());
        lastModeWasSetRef.current = true;
      }
      if (getLastFeature()) {
        setTo({
          star: {
            center: getLastFeature().center,
            label: getLabel(getLastFeature()),
          },
        });
      }
    }

    return () => {
      destroyRouting();
    };
  }, [mode, from, to, setMode, setFrom, setTo, setResult]);
};

type Option = any;

// generated by https://v0.dev/chat/3MwraSQEqCc
export const DirectionsForm = ({ setResult }) => {
  const [mode, setMode] = useState<string>('car');
  const [from, setFrom] = useState<Option>();
  const [to, setTo] = useState<Option>();

  useReactToUrl(setMode, setFrom, setTo, setResult);

  const onSubmit = () => {
    if (!from || !to) {
      return;
    }

    console.log('submit', mode, from, to);
    const fromCoords = getOptionCoords(from);
    const fromUrl = `${fromCoords}~${getOptionLabel(from)}`;
    const toCoords = getOptionCoords(to);
    const toUrl = `${toCoords}~${getOptionLabel(to)}`;

    const url = encodeUrl`/directions/${mode}/${fromUrl}/${toUrl}`;
    Router.push(url);
    if (url === Router.asPath) {
      handleRouting(mode, fromCoords, toCoords).then(setResult);
    }
  };

  const close = () => {
    Router.push('/');
  };

  return (
    <StyledPaper elevation={3}>
      <Stack direction="row" spacing={1} mb={2} alignItems="center">
        <ModeToggler value={mode} setMode={setMode} />
        <div style={{ flex: 1 }} />
        <div>
          <IconButton onClick={close} size="small" aria-label="close">
            <CloseIcon fontSize="small" />
          </IconButton>
        </div>
      </Stack>

      <Stack spacing={1} mb={3}>
        <DirectionsAutocomplete
          value={from}
          setValue={setFrom}
          label={t('directions.form.starting_point')}
        />
        <DirectionsAutocomplete
          value={to}
          setValue={setTo}
          label={t('directions.form.destination')}
        />
      </Stack>

      <Button
        variant="contained"
        fullWidth
        startIcon={<SearchIcon />}
        onClick={onSubmit}
      >
        {t('directions.get_directions')}
      </Button>
    </StyledPaper>
  );
};

const getHumanMetric = (meters) => {
  if (meters < 1000) {
    return `${meters} m`;
  }
  return `${(meters / 1000).toFixed(1)} km`;
};
const getHumanImperial = (meters) => {
  const miles = meters * 0.000621371192;
  if (miles < 1) {
    return `${Math.round(miles * 5280)} ft`;
  }
  return `${miles.toFixed(1)} mi`;
};
const toHumanDistance = (meters) =>
  isImperial() ? getHumanImperial(meters) : getHumanMetric(meters);

const toHumanTime = (seconds) => {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const minutesStr = minutes < 10 ? `0${minutes}` : minutes;
  return hours > 0 ? `${hours}:${minutesStr} h` : `${minutes} min`;
};

export const DirectionsBox = () => {
  const [result, setResult] = useState(null);
  return (
    <Wrapper spacing={1}>
      <DirectionsForm setResult={setResult} />
      {result && (
        <StyledPaper elevation={3}>
          Time:{' '}
          <strong>
            {toHumanTime(result.features[0].properties['total-time'])}
          </strong>
          <br />
          Distance:{' '}
          <strong>
            {toHumanDistance(result.features[0].properties['track-length'])}
          </strong>
          <br />
          Ascent:{' '}
          <strong>
            {toHumanDistance(result.features[0].properties['filtered ascend'])}
          </strong>
          <br />
          <br />
          <Typography variant="caption">
            Search proudly powered by{' '}
            <a href="https://www.brouter.de/brouter-web/">
              {result.features[0].properties.creator}
            </a>
            .
          </Typography>
        </StyledPaper>
      )}
    </Wrapper>
  );
};
